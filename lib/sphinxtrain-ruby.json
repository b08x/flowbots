{
  "files": [
    {
      "filename": "sphinxtrain-ruby.rb",
      "content": "require 'sphinxtrain'",
      "path": "/lib/"
    },
    {
      "filename": "sphinxtrain.rb",
      "content": "require \"pocketsphinx-ruby\"\nrequire \"colorize\"\nrequire \"word_aligner\"\n\nrequire \"sphinxtrain/version\"\nrequire \"sphinxtrain/analyser\"\nrequire \"sphinxtrain/map_adapter\"\nrequire \"sphinxtrain/acoustic_model\"\nrequire \"sphinxtrain/training_decoder\"\nrequire \"sphinxtrain/trainer\"\n\nmodule Sphinxtrain\n  def self.base_dir\n    File.join(Dir.home, '.sphinxtrain-ruby')\n  end\n\n  def self.recordings_dir\n    File.join(base_dir, 'recordings')\n  end\nend\n",
      "path": "/lib/"
    },
    {
      "filename": "acoustic_model.rb",
      "content": "module Sphinxtrain\n  class AcousticModel < Struct.new(:url)\n    MODEL_URLS = {\n      voxforge_grasch: \"http://files.kde.org/accessibility/Simon/am/voxforge_en_sphinx.cd_cont_5000.tar.gz\"\n    }\n\n    MODEL_DESCRIPTIONS = {\n      voxforge_grasch: \"Grasch Voxforge English 0.4\"\n    }\n\n    def self.voxforge_grasch\n      new MODEL_URLS[:voxforge_grasch]\n    end\n\n    def description\n      MODEL_DESCRIPTIONS[MODEL_URLS.invert[url]] || url\n    end\n\n    def downloaded?\n      File.exist?(downloaded_filename)\n    end\n\n    def downloaded_filename\n      File.basename(url)\n    end\n\n    def folder\n      File.basename(downloaded_filename, '.tar.gz')\n    end\n\n    def adapted_folder\n      folder + \"_adapted\"\n    end\n\n    def download!\n      `wget #{url}`\n      `tar xfz #{downloaded_filename}`\n    end\n\n    def duplicate!\n      FileUtils.rm_rf(adapted_folder) if Dir.exist?(adapted_folder)\n      FileUtils.cp_r(folder, adapted_folder)\n    end\n  end\nend\n",
      "path": "/lib/sphinxtrain/"
    },
    {
      "filename": "analyser.rb",
      "content": "module Sphinxtrain\n  class Analyser\n    def initialize(model)\n      configuration['hmm'] = model\n      configuration['seed'] = 1 # Ensure deterministic results\n    end\n\n    def analyse(sentences_file, recordings_dir)\n      total = 0\n      first_decoding = true\n\n      File.open(sentences_file).each_line.with_index do |transcription, index|\n        transcription = transcription.downcase.gsub(/[,\\.]/, '')\n        file_path = File.join(recordings_dir, \"arctic_#{(index + 1).to_s.rjust(4, \"0\")}.raw\")\n        decoder.decode file_path\n\n        # Repeat the first decoding after CMN estimations are calculated\n        # See https://github.com/watsonbox/pocketsphinx-ruby/issues/10\n        if first_decoding\n          first_decoding = false\n          redo\n        end\n\n        hypothesis = decoder.hypothesis\n        error_rate = WordAligner.align(transcription, hypothesis)\n        total += error_rate.percentage_accurate\n\n        if block_given?\n          yield transcription, hypothesis, error_rate.percentage_accurate\n        end\n      end\n\n      total / 20\n    end\n\n    private\n\n    def configuration\n      @configuration ||= Pocketsphinx::Configuration.default\n    end\n\n    def decoder\n      @decoder ||= Pocketsphinx::Decoder.new(configuration)\n    end\n  end\nend\n",
      "path": "/lib/sphinxtrain/"
    },
    {
      "filename": "map_adapter.rb",
      "content": "module Sphinxtrain\n  class MapAdapter\n    SPHINX_FE_COMMAND = \"sphinx_fe\"\n    BW_COMMAND = \"/usr/local/Cellar/cmu-sphinxtrain/HEAD/libexec/sphinxtrain/bw\"\n    MAP_ADAPT_COMMAND = \"/usr/local/Cellar/cmu-sphinxtrain/HEAD/libexec/sphinxtrain/map_adapt\"\n\n    attr_accessor :old_model, :new_model, :recordings_dir, :sentences_transcription, :sentences_files, :sentences_dict\n\n    def initialize(old_model:, new_model:, recordings_dir:, sentences_transcription:, sentences_files:, sentences_dict:)\n      self.old_model = old_model\n      self.new_model = new_model\n      self.recordings_dir = recordings_dir\n      self.sentences_transcription = sentences_transcription\n      self.sentences_files = sentences_files\n      self.sentences_dict = sentences_dict\n    end\n\n    def adapt\n      `#{SPHINX_FE_COMMAND} \\\n        -argfile #{new_model_file 'feat.params'} \\\n        -samprate 16000 \\\n        -c #{sentences_files} \\\n        -di #{recordings_dir} \\\n        -do #{recordings_dir} \\\n        -ei raw \\\n        -eo mfc \\\n        -seed 1 > /dev/null 2>&1`\n\n      `#{BW_COMMAND} \\\n        -hmmdir #{new_model} \\\n        -moddeffn #{new_model_file 'mdef'} \\\n        -ts2cbfn \".cont.\" \\\n        -feat 1s_c_d_dd \\\n        -cmn current \\\n        -agc none \\\n        -dictfn #{sentences_dict} \\\n        -ctlfn #{sentences_files} \\\n        -lsnfn #{sentences_transcription} \\\n        -accumdir #{recordings_dir} \\\n        -lda #{new_model_file 'feature_transform'} \\\n        -cepdir #{recordings_dir} > /dev/null 2>&1`\n\n      `#{MAP_ADAPT_COMMAND} \\\n        -meanfn #{old_model_file 'means'} \\\n        -varfn #{old_model_file 'variances'} \\\n        -mixwfn #{old_model_file 'mixture_weights'} \\\n        -tmatfn #{old_model_file 'transition_matrices'} \\\n        -accumdir #{recordings_dir} \\\n        -mapmeanfn #{new_model_file 'means'} \\\n        -mapvarfn #{new_model_file 'variances'} \\\n        -mapmixwfn #{new_model_file 'mixture_weights'} \\\n        -maptmatfn #{new_model_file 'transition_matrices'} > /dev/null 2>&1`\n    end\n\n    private\n\n    def old_model_file(file)\n      File.join(old_model, file)\n    end\n\n    def new_model_file(file)\n      File.join(new_model, file)\n    end\n  end\nend\n",
      "path": "/lib/sphinxtrain/"
    },
    {
      "filename": "trainer.rb",
      "content": "require 'fileutils'\n\nmodule Sphinxtrain\n  class Trainer\n    def acoustic_model\n      @acoustic_model ||= AcousticModel.voxforge_grasch\n    end\n\n    def train\n      Pocketsphinx.disable_logging\n\n      Dir.mkdir Sphinxtrain.base_dir rescue Errno::EEXIST\n      Dir.chdir Sphinxtrain.base_dir do\n        if acoustic_model.downloaded?\n          log \"=> Using existing acoustic model #{acoustic_model.description}\", :yellow\n        else\n          log \"=> Downloading #{acoustic_model.description}...\"\n          acoustic_model.download!\n        end\n\n        download_assets unless arctic_file(:txt, :listoffiles, :transcription, :dic).all? { |f| File.exist? f }\n\n        if Dir.exist?(Sphinxtrain.recordings_dir)\n          log \"=> Using sentences recorded in #{Sphinxtrain.recordings_dir}\", :yellow\n        else\n          record_sentences\n        end\n\n        result = analyse_model\n\n        duplicate_model\n        adapt_model\n\n        adapted_result = analyse_model acoustic_model.adapted_folder\n\n        improvement = ((adapted_result/result)-1)*100\n\n        log \"=> Adapted acoustic model improved by #{improvement}%. Test this model with:\"\n        log \"=> pocketsphinx_continuous -hmm #{File.join(Sphinxtrain.base_dir, acoustic_model.adapted_folder)} -inmic yes\"\n      end\n    end\n\n    private\n\n    def download_assets\n      log \"=> Downloading CMU ARCTIC Example Sentences...\"\n\n      arctic_file(:txt, :listoffiles, :transcription, :dic).each do |file|\n        `wget http://www.speech.cs.cmu.edu/cmusphinx/moindocs/#{file} -O #{file}`\n      end\n    end\n\n    def arctic_file(*keys)\n      keys.length == 1 ? \"arctic20.#{keys.first}\" : keys.map { |k| arctic_file k }\n    end\n\n    def record_sentences\n      log \"=> Recording sentences...\"\n      Dir.mkdir Sphinxtrain.recordings_dir unless Dir.exist?(Sphinxtrain.recordings_dir)\n\n      recognizer = Pocketsphinx::LiveSpeechRecognizer.new\n      decoder = TrainingDecoder.new(recognizer.decoder)\n      recognizer.decoder = decoder\n\n      # Initialize the decoder and microphone\n      recognizer.decoder.ps_decoder\n      recognizer.recordable\n\n      File.open(arctic_file(:txt), 'r').lines.each_with_index do |sentence, index|\n        puts \"SAY: #{sentence}\"\n        puts \"Press ENTER to continue\"\n        gets\n\n        # Small delay to avoid capturing audio connected with keypress\n        sleep 0.2\n\n        # Record a single utterance captured by TrainingDecoder\n        recognizer.recognize do |speech|\n          save_audio decoder.last_utterance, index\n          break\n        end\n\n        puts \"Saved audio\\n\\n\"\n      end\n    end\n\n    def save_audio(data, sentence_index)\n      raise \"Can't save empty audio data\" if data.nil? || data.empty?\n\n      File.open(File.join(Sphinxtrain.recordings_dir, \"arctic_#{(sentence_index + 1).to_s.rjust(4, \"0\")}.raw\"), \"wb\") do |file|\n        file.write data\n      end\n    end\n\n    def analyse_model(model_folder = acoustic_model.folder)\n      log \"=> Analysing acoustic model...\\n\"\n\n      result = Analyser.new(model_folder).analyse(arctic_file(:txt), Sphinxtrain.recordings_dir) do |transcription, hypothesis, accuracy|\n        puts \"   ACTUAL: #{transcription}\"\n        puts \"   RECORD: #{hypothesis}\"\n        puts \"   RESULT: #{accuracy}\\n\\n\"\n      end\n\n      puts \"   OVERALL: #{result}\\n\\n\"\n      result\n    end\n\n    def duplicate_model\n      log \"=> Duplicating Voxforge acoustic model...\"\n      acoustic_model.duplicate!\n    end\n\n    # Follows process described here: http://cmusphinx.sourceforge.net/wiki/tutorialadapt\n    def adapt_model\n      log \"=> Adapting Voxforge acoustic model...\"\n\n      MapAdapter.new(\n        old_model: acoustic_model.folder,\n        new_model: acoustic_model.adapted_folder,\n        recordings_dir: Sphinxtrain.recordings_dir,\n        sentences_transcription: arctic_file(:transcription),\n        sentences_files: arctic_file(:listoffiles),\n        sentences_dict: arctic_file(:dic)\n      ).adapt\n    end\n\n    def log(message, color = :green)\n      puts message.colorize(color)\n    end\n  end\nend\n",
      "path": "/lib/sphinxtrain/"
    },
    {
      "filename": "training_decoder.rb",
      "content": "module Sphinxtrain\n  # Wrap a decoder to save the last utterance\n  class TrainingDecoder < SimpleDelegator\n    attr_accessor :data\n    attr_accessor :last_utterance\n\n    def start_utterance(*args)\n      self.data = \"\"\n      super\n    end\n\n    def end_utterance(*args)\n      self.last_utterance = data\n      super\n    end\n\n    def process_raw(buffer, size, *args)\n      super\n      self.data << buffer.get_bytes(0, size * 2)\n    end\n  end\nend\n",
      "path": "/lib/sphinxtrain/"
    },
    {
      "filename": "version.rb",
      "content": "module Sphinxtrain\n  VERSION = \"0.0.3\"\nend\n",
      "path": "/lib/sphinxtrain/"
    },
    {
      "filename": "spec_helper.rb",
      "content": "# This file was generated by the `rspec --init` command. Conventionally, all\n# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.\n# The generated `.rspec` file contains `--require spec_helper` which will cause this\n# file to always be loaded, without a need to explicitly require it in any files.\n#\n# Given that it is always loaded, you are encouraged to keep this file as\n# light-weight as possible. Requiring heavyweight dependencies from this file\n# will add to the boot time of your test suite on EVERY test run, even for an\n# individual file that may not need all of that loaded. Instead, consider making\n# a separate helper file that requires the additional dependencies and performs\n# the additional setup, and require it from the spec files that actually need it.\n#\n# The `.rspec` file also contains a few flags that are not defaults but that\n# users commonly want.\n#\n# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration\nRSpec.configure do |config|\n  # rspec-expectations config goes here. You can use an alternate\n  # assertion/expectation library such as wrong or the stdlib/minitest\n  # assertions if you prefer.\n  config.expect_with :rspec do |expectations|\n    # This option will default to `true` in RSpec 4. It makes the `description`\n    # and `failure_message` of custom matchers include text for helper methods\n    # defined using `chain`, e.g.:\n    # be_bigger_than(2).and_smaller_than(4).description\n    #   # => \"be bigger than 2 and smaller than 4\"\n    # ...rather than:\n    #   # => \"be bigger than 2\"\n    expectations.include_chain_clauses_in_custom_matcher_descriptions = true\n  end\n\n  # rspec-mocks config goes here. You can use an alternate test double\n  # library (such as bogus or mocha) by changing the `mock_with` option here.\n  config.mock_with :rspec do |mocks|\n    # Prevents you from mocking or stubbing a method that does not exist on\n    # a real object. This is generally recommended, and will default to\n    # `true` in RSpec 4.\n    mocks.verify_partial_doubles = true\n  end\n\n# The settings below are suggested to provide a good initial experience\n# with RSpec, but feel free to customize to your heart's content.\n=begin\n  # These two settings work together to allow you to limit a spec run\n  # to individual examples or groups you care about by tagging them with\n  # `:focus` metadata. When nothing is tagged with `:focus`, all examples\n  # get run.\n  config.filter_run :focus\n  config.run_all_when_everything_filtered = true\n\n  # Limits the available syntax to the non-monkey patched syntax that is recommended.\n  # For more details, see:\n  #   - http://myronmars.to/n/dev-blog/2012/06/rspecs-new-expectation-syntax\n  #   - http://teaisaweso.me/blog/2013/05/27/rspecs-new-message-expectation-syntax/\n  #   - http://myronmars.to/n/dev-blog/2014/05/notable-changes-in-rspec-3#new__config_option_to_disable_rspeccore_monkey_patching\n  config.disable_monkey_patching!\n\n  # This setting enables warnings. It's recommended, but in some cases may\n  # be too noisy due to issues in dependencies.\n  config.warnings = true\n\n  # Many RSpec users commonly either run the entire suite or an individual\n  # file, and it's useful to allow more verbose output when running an\n  # individual spec file.\n  if config.files_to_run.one?\n    # Use the documentation formatter for detailed output,\n    # unless a formatter has already been configured\n    # (e.g. via a command-line flag).\n    config.default_formatter = 'doc'\n  end\n\n  # Print the 10 slowest examples and example groups at the\n  # end of the spec run, to help surface which specs are running\n  # particularly slow.\n  config.profile_examples = 10\n\n  # Run specs in random order to surface order dependencies. If you find an\n  # order dependency and want to debug it, you can fix the order by providing\n  # the seed, which is printed after each run.\n  #     --seed 1234\n  config.order = :random\n\n  # Seed global randomization in this process using the `--seed` CLI option.\n  # Setting this allows you to use `--seed` to deterministically reproduce\n  # test failures related to randomization by passing the same `--seed` value\n  # as the one that triggered the failure.\n  Kernel.srand config.seed\n=end\nend\n",
      "path": "/spec/"
    }
  ]
}
